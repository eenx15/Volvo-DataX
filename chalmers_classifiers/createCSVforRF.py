import dill
import csv
import pandas as pd
import jaad_data as gd
import math
import numpy as np
import random
import ast

from collections import defaultdict


def load(filename):
    """
    Loads the dill file created by running pedestrian_and_yolo.py
    :param filename: Name of the dill file
    :returns The defaultdict contained in the dill file
    """
    obj = dill.load(open(filename, 'rb'))

    return obj


def generate_csv(dictionary, seconds):
    """
    Generates the CSV-file, linking the features generated by running pedestrian_and_yolo.py, with crossing annotations
    in JAAD.
    :param dictionary: defaultdict created by running pedestrian_and_yolo.py
    :param seconds: offset to use when linking the detections with annotations. Ex. if 1, collect cross annotations for
    a pedestrian 1 sec in the future
    """
    # Load the JAAD annotations
    instance = gd.JAAD(data_path='../JAAD')

    # Create the CSV-file
    with open('feature_file_sec0_trainedModel.csv', 'w') as csv_file:

        # Create the fieldnames to use in the csv-file
        fieldnames = ['video_id', 'ped_ind', 'frame_number', 'bounding_boxes']
        for i in range(252):
            fieldnames.append('ang3-' + str(i))
        for i in range(36):
            fieldnames.append('ang-' + str(i))
        for i in range(36):
            fieldnames.append('xDist-' + str(i))
        for i in range(36):
            fieldnames.append('yDist-' + str(i))
        for i in range(36):
            fieldnames.append('sDist-' + str(i))

        fieldnames.append('crossing')

        writer = csv.DictWriter(csv_file, fieldnames=fieldnames)
        # writer = csv.writer(csv_file, delimiter=',')
        writer.writeheader()

        test = []
        idSet = []

        # Loop through every video
        for x in dictionary.keys():
            test.append(x)
            print(x)

            # Loop through every pedestrian
            for ids in dictionary[x].keys():
                idSet.append(ids)
                bounding_boxes_per_vid = []
                frameSet = []
                crossing_per_vid = []

                # deal is a dict containing the features for a pedestrian. The keys are the names of the features,
                # and the values the corresponding features
                deal = defaultdict(list)

                # Loop through every frame where the pedestrian is visible
                for frames in dictionary[x][ids]:
                    fps = dictionary[x][ids][frames]['fps']

                    bounding_box = dictionary[x][ids][frames]['BB']
                    xb = bounding_box[0]
                    y = bounding_box[1]
                    w = bounding_box[2]
                    h = bounding_box[3]

                    # Ignore this frame in the iteration, if the frame is exceeding boundaries (due to offset),
                    # or if there are no annotations for this pedestrian in JAAD.
                    if isCrossingAfterTime(fps, seconds, instance, str(x), frames, xb, y, w, h) == -1:
                        continue
                    else:
                        crossing_per_vid.append(
                            isCrossingAfterTime(fps, seconds, instance, str(x), frames, xb, y, w, h))

                    frameSet.append(frames)

                    bounding_boxes_per_vid.append(dictionary[x][ids][frames]['BB'])

                    # Add every feature to the dict deal, if some feature is missing, pad this missing feature with 0.0

                    if len(dictionary[x][ids][frames]['angles3']) == 0:
                        print('nill')
                    else:
                        for A3part in range(len(dictionary[x][ids][frames]['angles3'])):
                            if dictionary[x][ids][frames]['angles3'][A3part] is None:
                                print('none')
                                deal['ang3-' + str(A3part)].append(0.0)
                            else:
                                deal['ang3-' + str(A3part)].append(dictionary[x][ids][frames]['angles3'][A3part])

                    if len(dictionary[x][ids][frames]['angles']) == 0:
                        print('nill')
                    else:
                        for Apart in range(len(dictionary[x][ids][frames]['angles'])):
                            if dictionary[x][ids][frames]['angles'][Apart] is None:
                                print('none')
                                deal['ang-' + str(Apart)].append(0.0)
                            else:
                                deal['ang-' + str(Apart)].append(dictionary[x][ids][frames]['angles'][Apart])

                    if len(dictionary[x][ids][frames]['xDist']) == 0:
                        print('nill')
                    else:
                        for Xpart in range(len(dictionary[x][ids][frames]['xDist'])):
                            if dictionary[x][ids][frames]['xDist'][Xpart] is None:
                                print('none')
                                deal['xDist-' + str(Xpart)].append(0.0)
                            else:
                                deal['xDist-' + str(Xpart)].append(dictionary[x][ids][frames]['xDist'][Xpart])

                    if len(dictionary[x][ids][frames]['yDist']) == 0:
                        print('nill')
                    else:
                        for Ypart in range(len(dictionary[x][ids][frames]['yDist'])):
                            if dictionary[x][ids][frames]['yDist'][Ypart] is None:
                                print('none')
                                deal['yDist-' + str(Ypart)].append(0.0)
                            else:
                                deal['yDist-' + str(Ypart)].append(dictionary[x][ids][frames]['yDist'][Ypart])

                    if len(dictionary[x][ids][frames]['sDist']) == 0:
                        print('nill')
                    else:
                        for Spart in range(len(dictionary[x][ids][frames]['sDist'])):
                            if dictionary[x][ids][frames]['sDist'][Spart] is None:
                                print('none')
                                deal['sDist-' + str(Spart)].append(0.0)
                            else:
                                deal['sDist-' + str(Spart)].append(dictionary[x][ids][frames]['sDist'][Spart])

                BB = [list(p) for p in bounding_boxes_per_vid]

                # Also add this data to deal, besides the features
                deal['video_id'] = x
                deal['bounding_boxes'] = BB
                deal['ped_ind'] = ids
                deal['frame_number'] = frameSet
                deal['crossing'] = crossing_per_vid

                # Write the content of deal to the csv-file
                writer.writerow(deal)


def isCrossingAfterTime(fps, seconds, instance, video_id, frame, x, y, w, h):
    """
    Calculates offset used for collecting the annotations, and then calls the function isCrossing()
    :param fps: fps in the video
    :param seconds: offset used for collecting annotations, in seconds
    :param instance: JAAD instance
    :param video_id: video_id
    :param frame: frame index
    :param x,y,w,h: bounding box coordinates for the pedestrian
    """
    offset = int(fps * seconds)
    annotations = instance._get_annotations(video_id)
    frames = annotations['num_frames']

    # Check if exceeding boundaries
    if frames < frame + offset:
        return -1
    else:
        return isCrossing(annotations, offset, frame, x, y, w, h)


def isCrossing(annotations, offset, frame, x, y, w, h):
    """
    Collects the crossing annotations from JAAD
    :param annotations: JAAD annotations (object returned from function _get_annotations() in jaad_data.py)
    :param offset: offset used for collecting annotations, in frames
    :param frame: frame index
    :param x,y,w,h: bounding box coordinates for the pedestrian
    """

    # Return -1 if no annotations found for the pedestrian
    peds = annotations['ped_annotations']
    pedestrian = getPedestrian(peds, frame, x, y, w, h)
    if not pedestrian:
        return -1
    firstFrame = pedestrian['frames'][0]

    # Return -1 if there is no behaviour-data for the pedestrian in JAAD
    if 'behavior' not in pedestrian.keys():
        return -1
    if not pedestrian['behavior']:
        return -1

    # Collect C/NC annotations as described in the paper "Intention Recognition of Pedestrians and Cyclists by 2D Pose Estimation" by Fang and M. Lopez

    if (len(pedestrian['behavior']['cross']) >= frame - firstFrame + offset):
        if (pedestrian['behavior']['cross'][frame - firstFrame + offset - 1] == 1):
            return 1
    if 'attributes' in pedestrian.keys():
        if pedestrian['attributes'] is not None:
            if (len(pedestrian['behavior']['reaction']) >= frame - firstFrame + offset) and (len(pedestrian['attributes']['motion_direction'][frame - firstFrame + offset - 1]) >= frame - firstFrame + offset):
                if (pedestrian['behavior']['reaction'][frame - firstFrame + offset - 1] != 0) and (pedestrian['attributes']['motion_direction'][frame - firstFrame + offset - 1] == 1):
                    return 1
    else:
        return 0




def getMidpoint(x, y, w, h):
    """
    Helper function for calculating the center point of bounding box using tlwh coordinates
    """
    x_point = x + (w/2)
    y_point = y + (h/2)

    return x_point, y_point


def getBboxMidPoint(bbox):
    """
    Helper function for calculating the center point in bounding box, where the tlwh coordinates are contained in a list
    """
    x_point = (bbox[0] + bbox[2]) / 2
    y_point = (bbox[1] + bbox[3]) / 2

    return x_point, y_point


def compute_difference(bbox, x, y, w, h):
    """
    Helper function for calculating shortest distance between two bounding boxes, using the center coordinates
    """
    boxX, boxY = getBboxMidPoint(bbox)
    inX, inY = getMidpoint(x, y, w, h)
    difX = abs(boxX - inX)
    difY = abs(boxY - inY)
    dist = math.sqrt(difX**2 + difY**2)
    return dist


def getPedestrian(peds, frameNo, x, y, w, h):
    """
    This function finds the closest annotated pedestrian bounding box, to the detected bounding box
    :param peds: annotations['ped_annotations']. annotations are returned by the function _get_annotations() in jaad_data.py
    :param frameNo: current frame
    :param x,y,w,h: bounding box coordinates for the detected pedestrian
    :returns Element in peds corresponding to the closest annotated pedestrian bounding box
    """

    closest = -1
    closestPed = ''

    for p in peds.keys():
        firstFrame = peds[p]['frames'][0]
        appearsIn = len(peds[p]['frames'])
        frameDiff = frameNo - firstFrame

        if frameNo >= firstFrame and frameDiff < appearsIn:
            bbox = peds[p]['bbox'][frameDiff]
            dist = compute_difference(bbox, x, y, w, h)
            if (closest == -1 or dist < closest) and dist < 50:
                closest = dist
                closestPed = peds[p]

    return closestPed



if __name__ == "__main__":
    # This variable controls how far in the future the classifier will be trained
    seconds = 0
    generate_csv(load('skeletonFeaturesTrainedModel'), seconds)
